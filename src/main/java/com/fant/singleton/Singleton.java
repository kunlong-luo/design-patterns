package com.fant.singleton;

/**
 * 单例模式
 * <p>
 * 概念：单例是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。
 * （跟结婚一样，中国法律规定实行一夫一妻制，那么，你要找我老婆麻烦，你得先问问我）
 * <p>
 * 问题：单例模式同时解决了两个问题，所以违反了【单一职责原则】
 * 1.保证一个类只有一个实例。为什么会有人想要控制一个类所拥有的实例数量呢？最常见的原因是控制某些共享资源（数据库、文件）的访问权限。
 * 而普通的构造函数无法实现上述行为，因为构造函数的设计决定了它必须总是返回一个新对象。
 * 而单例模式的运作方式：如果你创建了一个对象，同时你一会又要创建一个新对象，那么你会获得这个对象，而不是一个新对象。
 * 2.为该实例提供了一个全局访问点。和全局变量一样，单例模式也允许在程序的任何地方访问特定对象。但是它可以保护该实例不被其他代码覆盖。
 * 你不会希望解决同一个问题的代码分散在程序各处的。因此更好的方式是将其放在同一个类中，特别是当其他代码已经依赖这个类时更应该如此。
 * 如今，单例模式已经变得非常流行，以至于人们会将只解决上文描述中任意一个问题的东西称为​单例​。
 * 实现：
 * 1.在类中添加一个私有静态成员变量用于保存单例实例。
 * 2.声明一个共有静态创建方法用于获取单例实例。
 * 3.在静态方法中实现"延迟初始化"。该方法会在首次被调用时创建一个新对象，并将其存储在静态成员变量中。此后该方法每次被调用时都返回该实例。
 * 4.将类的构造函数设为私有。类的静态方法仍能调用构造函数，但是其他对象不能调用。
 * 5.检查客户端代码，将对单例的构造函数调用替换为对其静态创建方法调用。
 * <p>
 * 优点：
 * 1.你可以保证一个类只有一个实例。
 * 2.你获得了一个指向该实例的全局访问节点。
 * 3.仅在首次请求单例对象时对其进行初始化。
 * <p>
 * 缺点：
 * 1.违反了[单一职责原则]。该模式同时解决了两个问题。
 * 2.单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多等。
 * 3.该模式在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。
 * 4.单例的客户端代码单元测试可能会比较困难，因为许多测试框架以基于继承的方式创建模拟对象。
 * 由于单例类的构造函数是私有的，而且绝大部分语言无法重写静态方法，所以你需要想出仔细考虑模拟单例的方法。
 * 要么干脆不编写测试代码，或者不使用单例模式。
 * <p>
 * 联系：
 * 1.外观类通常可以转换为单例类，因为在大部分情况下一个外观对象就足够了。
 * 2.如果你能将对象的所有共享状态简化为一个享元对象，那么享元就和单例类似了。但是这两个模式有两个根本性的不同。
 * 3.抽象工厂、生成器和原型都可以用单例来实现。
 */


public class Singleton {

    /**
     * 双重校验锁-线程安全 （推荐，但是实现逻辑比较难以理解）
     * singleton 只需要被实例化一次，之后就可以直接使用了。
     * 加锁操作只需要对实例化那部分的代码进行，只有当 singleton 没有被实例化时，才需要进行加锁。
     * 双重校验锁先判断 singleton 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。
     * 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行
     */

    private static volatile Singleton singleton;

    private Singleton() {
    }

    public static Singleton getInstance() {
        // 避免 singleton 已经被实例化之后的加锁操作
        if (singleton == null) {
            // 加锁
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}

//class SingletonByInnerClass {
//
//
//    /**
//     * 静态内部类（推荐使用,目前无法使用）
//     * 当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。
//     * 只有当调用 getsingleton() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，
//     * 此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。
//     * 这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。
//     */
//    private SingletonByInnerClass() {
//    }
//
//    private static class SingletonHolder {
//
//        static final SingletonByInnerClass SINGLETON = new SingletonByInnerClass();
//    }
//
//    public static SingletonByInnerClass getInstance() {
//        return SingletonByInnerClass.SingletonHolder;
//    }
//}



